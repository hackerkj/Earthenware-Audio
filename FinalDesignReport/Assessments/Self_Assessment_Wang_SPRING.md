My individual contribution was to create the overall outline of the project for team members to build from. In my initial assessment, I anticipated that I would use my knowledge about design patterns, data structures, and data analysis to be useful in creating the key detector. In practice all three of these skills were used at points. For example, I encountered a problem where many graphical items required an interface to the same real time interface. Passing a series of redundant sets and gets along the object tree would be hard to maintain. I solved this by conjoining all the audio functions into one audio analysis system in the form of a singleton design pattern. There is only one audio subsystem, so the singleton fit my needs. A second problem that needed solved was in the performance area. In audio programming, the audio thread is a real time thread that cannot block for any amount of time or the plugin will receive undefined input. A first-in first-out (FIFO) queue in the form of a ring buffer solved this problem. The key detection function took up to a second to run so it needed to be handled on its own thread. The FIFO queue allowed data to be passed to the key detection buffer for analysis asynchronously from the time sensitive audio thread. This project built on my knowledge of design patterns and data structures.

The first obstacle to overcome was learning how to use a framework. Our project used JUCE, which is open source and well documented, however there was still a learning curve in learning the base components. I successfully created a template that could be developed into our full program by watching video tutorials for starting a JUCE project. The second obstacle I encountered was integrating the key detector library. The library required a high performance FFT library called FFTW.  My initial solution was to use JUCE’s built in FFT library, this would be the most compatible solution but after much trial and error I was unable to determine why my outputs failed the integration tests included with the key detection library. I then tried the original, recommended FFTW library approach. There were some references for linking windows .dll files to a project on the web, but fewer for the most JUCE compatible way to perform it. I eventually found a resource on the forums that allowed me to successfully link the library to my program as the framework would expect. The next obstacle was increasing portability. Using JUCE’s FFT library would allow our code to be easily ported to Windows, linux, and even mobile. In the end, the end state for our plugin was for it to be, as the name implies, a plugin. This would have been in the vst or vst3 format, but as a vst3 plugin or vst .dll file, the external FFTW library could not be linked. This problem was left unsolved.
